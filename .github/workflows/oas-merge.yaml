name: OAS ‚Üí Working Collection (PR + optional publish)

on:
  push:
    branches:
      - "**"
    paths:
      - "openapi/demo-v2.yaml"
      - "collections/working.json"
  pull_request:
    paths:
      - "openapi/**"

permissions:
  contents: write
  pull-requests: write

env:
  NODE_VERSION: "20"
  OPENAPI_VERSION: "latest"

jobs:
  # Validate inputs and run security checks
  validate:
    runs-on: ubuntu-latest
    outputs:
      should-merge: ${{ steps.check-changes.outputs.should-merge }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need previous commit for comparison

      - name: Setup Node (with npm cache)
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: |
          npm ci || npm i
          npm i -g openapi-to-postmanv2@${{ env.OPENAPI_VERSION }} @apidevtools/swagger-cli

      - name: Security audit dependencies
        run: npm audit --audit-level moderate

      - name: Validate OpenAPI specs
        run: |
          for f in openapi/*.*; do
            echo "Validating $f..."
            if [[ "$f" == *.yaml ]] || [[ "$f" == *.yml ]]; then
              swagger-cli validate "$f" || {
                echo "‚ùå Invalid OpenAPI spec: $f"
                exit 1
              }
            fi
          done

      - name: Validate existing collections
        run: |
          if [ -f collections/working.json ]; then
            echo "Validating working collection..."
            jq empty collections/working.json || {
              echo "‚ùå Invalid JSON in working collection"
              exit 1
            }
          fi

      - name: Check if merge should run
        id: check-changes
        run: |
          if [ "${{ github.event_name }}" == "pull_request" ] || git diff --name-only HEAD~1 | grep -E "(openapi/|collections/)" > /dev/null; then
            echo "should-merge=true" >> $GITHUB_OUTPUT
          else
            echo "should-merge=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No relevant changes detected, skipping merge"
          fi

  merge:
    needs: validate
    if: needs.validate.outputs.should-merge == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node (with npm cache)
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: |
          npm ci || npm i
          npm i -g openapi-to-postmanv2@${{ env.OPENAPI_VERSION }}

      - name: Build Reference collections
        run: |
          mkdir -p ref
          echo "Converting OpenAPI specs to Postman collections..."
          
          # Read folderOrganization option from config (default to "Paths" if not set)
          folder_strategy="Paths"
          if [ -f "config/merge.config.yaml" ]; then
            folder_opt=$(grep -A 10 "^options:" config/merge.config.yaml | grep "folderOrganization:" | sed 's/.*folderOrganization: *"\([^"]*\)".*/\1/' | tr -d '"')
            if [ ! -z "$folder_opt" ]; then
              folder_strategy="$folder_opt"
            fi
          fi
          
          echo "Using folder organization strategy: $folder_strategy"
          
          for f in openapi/*.*; do
            base=$(basename "$f")
            out="ref/${base%.*}.postman_collection.json"
            echo "Converting $f ‚Üí $out (folder strategy: $folder_strategy)"
            
            openapi2postmanv2 -s "$f" -o "$out" -p -O folderStrategy="$folder_strategy" || {
              echo "‚ùå Failed to convert $f"
              exit 1
            }
            
            # Validate the generated collection
            jq empty "$out" || {
              echo "‚ùå Generated invalid JSON: $out"
              exit 1
            }
            
            echo "‚úÖ Successfully converted $f"
          done

      - name: Merge Reference ‚Üí Working (write merged artifact)
        run: |
          echo "Running merge process..."
          
          # Run with enhanced logging
          DEBUG=1 node scripts/merge.js \
            --config config/merge.config.yaml \
            --working collections/working.json \
            --refdir ref \
            --out collections/working.merged.json || {
            echo "‚ùå Merge process failed"
            exit 1
          }
          
          # Validate merged output
          jq empty collections/working.merged.json || {
            echo "‚ùå Merge produced invalid JSON"
            exit 1
          }
          
          echo "‚úÖ Merge completed successfully"

      # Generate changelog BEFORE copy/normalize so it reflects real adds/retires.
      - name: Generate changelog (pre-normalize)
        run: |
          echo "Generating semantic changelog..."
          
          DEBUG=1 node scripts/enhanced-changelog.js \
            --before collections/working.json \
            --after  collections/working.merged.json \
            --out CHANGELOG.md || {
            echo "‚ùå Changelog generation failed"
            exit 1
          }
          
          echo "‚úÖ Changelog generated successfully"

      - name: Copy merged over Working (stage for PR)
        run: cp collections/working.merged.json collections/working.json

      - name: Normalize for stable diffs
        run: node scripts/normalize.js collections/working.json

      - name: Canonical JSON key order (global, stable)
        run: |
          jq -S . collections/working.json > collections/working.sorted.json
          mv collections/working.sorted.json collections/working.json

      - name: Validate final output
        run: |
          echo "Final validation of merged collection..."
          
          # Ensure it's valid JSON
          jq empty collections/working.json || {
            echo "‚ùå Final collection is invalid JSON"
            exit 1
          }
          
          # Check it has required Postman collection structure
          if ! jq -e '.info.name' collections/working.json > /dev/null; then
            echo "‚ùå Missing required collection info.name"
            exit 1
          fi
          
          echo "‚úÖ Final collection validation passed"

      - name: Commit and open/update PR
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "OAS merge: update Working collection"
          title: "üîÑ OAS merge: update Working collection"
          body-path: CHANGELOG.md
          branch: oas-merge/update-working
          base: main
          add-paths: |
            collections/working.json
            CHANGELOG.md
          labels: |
            automation
            postman-merge

  publish:
    # Only run when merging PR (detected by commit message) on main/video-demo branches  
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/video-demo') && contains(github.event.head_commit.message, 'OAS merge:')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm ci || npm i

      - name: Validate environment
        env:
          POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
          WORKING_COLLECTION_UID: ${{ vars.WORKING_COLLECTION_UID }}
        run: |
          if [ -z "$POSTMAN_API_KEY" ]; then
            echo "‚ùå POSTMAN_API_KEY secret not configured"
            exit 1
          fi
          
          if [ -z "$WORKING_COLLECTION_UID" ]; then
            echo "‚ùå WORKING_COLLECTION_UID variable not configured"
            exit 1
          fi
          
          echo "‚úÖ Environment validation passed"

      - name: Validate collection before publish
        run: |
          FILE="collections/working.json"
          
          if [ ! -f "$FILE" ]; then
            echo "‚ùå Working collection not found: $FILE"
            exit 1
          fi
          
          # Validate JSON structure
          jq empty "$FILE" || {
            echo "‚ùå Invalid JSON in working collection"
            exit 1
          }
          
          # Check collection has required fields
          if ! jq -e '.info.name' "$FILE" > /dev/null; then
            echo "‚ùå Collection missing required info.name"
            exit 1
          fi
          
          echo "‚úÖ Collection validation passed"

      - name: Push merged Working back to Postman
        env:
          POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
          WORKING_COLLECTION_UID: ${{ vars.WORKING_COLLECTION_UID }}
        run: |
          FILE="collections/working.json"
          
          echo "üì§ Publishing collection to Postman..."
          echo "Collection: $(jq -r '.info.name' "$FILE")"
          echo "Target UID: $WORKING_COLLECTION_UID"
          
          # Create API payload
          jq -n --argjson c "$(cat "$FILE")" '{collection:$c}' > payload.json
          
          # Make API call with error handling
          response=$(curl -sS -w "\n%{http_code}" -X PUT \
            -H "X-Api-Key: $POSTMAN_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload.json \
            "https://api.getpostman.com/collections/$WORKING_COLLECTION_UID")
          
          # Parse response
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n -1)
          
          # Check for success
          if [ "$http_code" -eq 200 ]; then
            echo "‚úÖ Successfully published to Postman"
            echo "$body" | jq -r '.'
          else
            echo "‚ùå Failed to publish to Postman (HTTP $http_code)"
            echo "$body" | jq -r '.' || echo "$body"
            exit 1
          fi
          
          # Clean up sensitive payload
          rm -f payload.json